# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PanoramaViewerDialog
                                 A QGIS plugin
 A simple panorama viewer for QGIS. Based on QWebView with Pannellum js library
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-05-26
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Pavel Pereverzev
        email                : pasha004@yandex.ru
 ***************************************************************************/

/***************************************************************************
 * *
 * This program is free software; you can redistribute it and/or modify  *
 * it under the terms of the GNU General Public License as published by  *
 * the Free Software Foundation; either version 2 of the License, or     *
 * (at your option) any later version.                                   *
 * *
 ***************************************************************************/
"""
import os
import json 
import math 
import requests

from http.server import HTTPServer, SimpleHTTPRequestHandler
from urllib.parse import urlparse

from qgis.utils import iface
from qgis._core import *
from qgis._gui import *

from PyQt5.QtCore import QThread, QSize


from PyQt5.QtWebKitWidgets import QWebView, QWebPage
from PyQt5 import *
from PyQt5 import QtCore
from PyQt5.QtWidgets import (
    QVBoxLayout,
    QWidget,
    QCheckBox,
    QHBoxLayout,
    QGridLayout,
    QPushButton,
    QMessageBox,
    QProgressBar,
    QDockWidget,
    QComboBox,
    QMainWindow,
    QSizePolicy,
    QStyle,
    QLabel
)
from PyQt5.QtGui import *
from PyQt5.QtCore import *

from PyQt5.QtGui import QSurfaceFormat
format = QSurfaceFormat()
format.setProfile(QSurfaceFormat.CompatibilityProfile)
QSurfaceFormat.setDefaultFormat(format)

from qgis.gui import QgsMapLayerComboBox, QgsFileWidget
from qgis.core import QgsVectorLayer, QgsProject, QgsFeatureRequest, QgsPointXY, QgsGeometry, QgsProject, QgsVectorLayer, QgsMapLayerProxyModel
from PyQt5.QtWidgets import QLineEdit
from PyQt5.QtCore import QUrl
import requests

base_folder = os.path.dirname(os.path.realpath(__file__))

HOST, PORT = "", 8030

def circle_geom(pnt, w, h):
    list_circle =[]
    for i in range(0,36):
        an =math.radians(i * 10)
        np_x = pnt.x() + (w* math.sin(an))
        np_y = pnt.y() + (h* math.cos(an))
        pnt_new = QgsPointXY(np_x,np_y) 
        list_circle.append(pnt_new) 
    ellipse_geom = QgsGeometry.fromPolygonXY([list_circle])
    return ellipse_geom


def read_in_chunks(file_object, chunk_size=None):
    while True:
        data = file_object.read(chunk_size)
        if not data:
            break
        yield data


class GetPanorama(QWidget):
    def __init__(self, parent):
        super().__init__()
        self.main_app = parent

    def get_pano_file(self, file_url, method):
        if method == "download":
            result = self.download(file_url)
        else:
            result = self.copy_file(file_url)
        return result

    def download(self, url):
        self.main_app.pbar.setDisabled(False)
        r = requests.get(url, allow_redirects=True, stream=True)
        if r.status_code != 200:
            return False
        total_length = r.headers.get("content-length")
        if total_length is None: # No content length header
            return False
        total_length = int(total_length)
        file_name = os.path.join(base_folder, "image.JPG")
        if total_length: 
            with open(file_name, "wb") as f:
                p_step = 100 / total_length * 4096 if total_length > 0 else 0
                counter = 0
                for data in r.iter_content(chunk_size=4096):
                    counter += p_step
                    f.write(data)
                    self.main_app.pbar.setValue(int(counter))
                    QtCore.QCoreApplication.processEvents()
        self.main_app.pbar.setValue(0)
        self.main_app.pbar.setDisabled(True)
        return True

    def copy_file(self, file_in):
        self.main_app.pbar.setDisabled(False)
        file_out = os.path.join(base_folder, "image.JPG")
        file_stats = os.stat(file_in)
        size_b = file_stats.st_size
        ch_optimal_size = int(size_b / 100) if size_b > 100 else size_b
        p_step = 100 / size_b * ch_optimal_size if size_b > 0 else 0
        counter = 0
        open(file_out, "w").close()
        with open(file_in, "rb") as f:
            for piece in read_in_chunks(f, ch_optimal_size):
                with open(file_out, "ab") as fout:
                    fout.write(piece)
                counter += p_step
                self.main_app.pbar.setValue(int(counter))
                QtCore.QCoreApplication.processEvents()
        self.main_app.pbar.setValue(0)
        self.main_app.pbar.setDisabled(True)
        return True


class QuietHandler(SimpleHTTPRequestHandler):
    def log_message(self, format, *args):
        pass


class HttpDaemon(QtCore.QThread):
    def __init__(self, parent, path):
        super(QThread, self).__init__()
        self.server_path = path

    def run(self):
        os.chdir(self.server_path)
        self.server = HTTPServer((HOST, PORT), QuietHandler)
        self.server.serve_forever()

    def stop(self):
        self.server.shutdown()
        self.server.socket.close()


class PanoramaViewerDialog(QDockWidget):
    def __init__(self, wrapper):
        QDockWidget.__init__(self)
        self.wrapper = wrapper
        self.resize(480, 480)
        self.setWindowTitle("Salvador 360°")
        self.gv = PanoramaViewer(self)
        self.gv.setMinimumSize(QSize(480, 480))
        self.setWidget(self.gv)
        self.closeEvent = self.onDestroy
        self.wrapper.plugin_is_opened = True

    def onDestroy(self, e):
        self.wrapper.plugin_is_opened = False
        self.gv.reset_tr()
        iface.mapCanvas().selectionChanged.disconnect(self.gv.get_pic_on_selection)
        if self.gv.rubberBandArrow:
            self.gv.rubberBandArrow.reset()


class WebPage(QWebPage):
    def __init__(self, main_view):
        super().__init__()
        self.mv = main_view
    def javaScriptConsoleMessage(self, msg, line, source):
        try:
            data = json.loads(msg)
            self.mv.update_arrow(data)
        except json.JSONDecodeError:
            pass


class PanoramaViewer(QMainWindow):
    # Substitua a função __init__ inteira por esta:
    def __init__(self, parent):
        super().__init__(parent=None)
        
        self.wrapper = parent
        self.setWindowFlags(self.windowFlags() | QtCore.Qt.WindowStaysOnTopHint)
        self.setWindowTitle("Salvador 360°")
        self.setGeometry(800, 650, 1200, 880)

        self.httpd = None
        self.current_panorama_layer = None # Camada de panorama atualmente filtrada

        centralWidget = QWidget()
        main_layout = QVBoxLayout(centralWidget)
        browser_layout = QHBoxLayout()
        grid_layout = QGridLayout()
        grid_layout.setSpacing(10)

        # --- Visualizador de Panorama ---
        self.view = QWebView(self)
        sp = self.view.sizePolicy()
        sp.setVerticalPolicy(QSizePolicy.Expanding)
        self.view.setSizePolicy(sp)
        self.view.settings().setObjectCacheCapacities(0, 0, 0)
        self.page = WebPage(self)
        self.view.setPage(self.page)
        browser_layout.addWidget(self.view)

        # --- Seleção de Camadas e Campos ---
        # Camada de Bairros
        self.lbl_bairro_layer = QLabel("Camada de Bairros:")
        self.cmb_bairro_layer = QgsMapLayerComboBox(self)
        self.cmb_bairro_layer.setFilters(QgsMapLayerProxyModel.PolygonLayer)

        self.lbl_bairro_field = QLabel("Campo 'Nome do Bairro':")
        self.cmb_bairro_field = QComboBox(self)

        # Camada de Logradouros
        self.lbl_logradouro_layer = QLabel("Camada de Logradouros:")
        self.cmb_logradouro_layer = QgsMapLayerComboBox(self)
        self.cmb_logradouro_layer.setFilters(QgsMapLayerProxyModel.LineLayer)

        self.lbl_logradouro_field = QLabel("Campo 'Codlog':")
        self.cmb_logradouro_field = QComboBox(self)

        # Camada de Panoramas
        self.lbl_panorama_layer = QLabel("Camada de Panoramas:")
        self.cmb_panorama_layer = QgsMapLayerComboBox(self)
        self.cmb_panorama_layer.setFilters(QgsMapLayerProxyModel.PointLayer)
        
        self.lbl_panorama_codlog_field = QLabel("Campo 'Codlog' do Panorama:")
        self.cmb_panorama_codlog_field = QComboBox(self)

        self.lbl_panorama_url_field = QLabel("Campo 'URL/Nome do Arquivo':")
        self.cmb_panorama_url_field = QComboBox(self)
        
        # Pasta de Imagens
        self.lbl_image_folder = QLabel("Pasta das Imagens Panorâmicas:")
        self.file_widget_image_folder = QgsFileWidget(self)
        self.file_widget_image_folder.setStorageMode(QgsFileWidget.StorageMode.SelectFolder)

        # --- Filtros ---
        self.lbl_bairro_select = QLabel("Selecione o Bairro:")
        self.cmb_bairro_select = QComboBox(self)
        
        self.lbl_logradouro_select = QLabel("Selecione o Logradouro (Codlog):")
        self.cmb_logradouro_select = QComboBox(self)

        # --- Botões e Controles ---
        self.btn_filtrar = QPushButton("Filtrar e Exibir Pontos")
        self.pbar = QProgressBar(self)
        self.pbar.setDisabled(True)

        # --- Montagem do Layout ---
        grid_layout.addWidget(self.lbl_bairro_layer, 0, 0)
        grid_layout.addWidget(self.cmb_bairro_layer, 0, 1)
        grid_layout.addWidget(self.lbl_bairro_field, 0, 2)
        grid_layout.addWidget(self.cmb_bairro_field, 0, 3)

        grid_layout.addWidget(self.lbl_logradouro_layer, 1, 0)
        grid_layout.addWidget(self.cmb_logradouro_layer, 1, 1)
        grid_layout.addWidget(self.lbl_logradouro_field, 1, 2)
        grid_layout.addWidget(self.cmb_logradouro_field, 1, 3)

        grid_layout.addWidget(self.lbl_panorama_layer, 2, 0)
        grid_layout.addWidget(self.cmb_panorama_layer, 2, 1)
        grid_layout.addWidget(self.lbl_panorama_codlog_field, 2, 2)
        grid_layout.addWidget(self.cmb_panorama_codlog_field, 2, 3)
        
        grid_layout.addWidget(self.lbl_panorama_url_field, 3, 2)
        grid_layout.addWidget(self.cmb_panorama_url_field, 3, 3)

        grid_layout.addWidget(self.lbl_image_folder, 4, 0, 1, 4)
        grid_layout.addWidget(self.file_widget_image_folder, 5, 0, 1, 4)

        grid_layout.addWidget(self.lbl_bairro_select, 6, 0)
        grid_layout.addWidget(self.cmb_bairro_select, 6, 1)
        grid_layout.addWidget(self.lbl_logradouro_select, 6, 2)
        grid_layout.addWidget(self.cmb_logradouro_select, 6, 3)

        main_layout.addLayout(browser_layout)
        main_layout.addLayout(grid_layout)
        main_layout.addWidget(self.btn_filtrar)
        main_layout.addWidget(self.pbar)
        
        self.setCentralWidget(centralWidget)

        # --- Conexões (Sinais e Slots) ---
        self.cmb_bairro_layer.layerChanged.connect(self.popular_campos_bairro)
        self.cmb_logradouro_layer.layerChanged.connect(self.popular_campos_logradouro)
        self.cmb_panorama_layer.layerChanged.connect(self.popular_campos_panorama)
        
        self.cmb_bairro_field.currentIndexChanged.connect(self.popular_valores_bairro)
        self.cmb_bairro_select.currentIndexChanged.connect(self.popular_valores_logradouro)

        self.btn_filtrar.clicked.connect(self.filtrar_e_exibir_pontos)
        
        iface.mapCanvas().selectionChanged.connect(self.visualizar_panorama_selecionado)

        self.httpd = HttpDaemon(self, base_folder)
        self.httpd.start()

    def popular_campos_bairro(self, layer):
        self.cmb_bairro_field.clear()
        if not layer: return
        self.cmb_bairro_field.addItems([field.name() for field in layer.fields()])

    def popular_campos_logradouro(self, layer):
        self.cmb_logradouro_field.clear()
        if not layer: return
        self.cmb_logradouro_field.addItems([field.name() for field in layer.fields()])

    def popular_campos_panorama(self, layer):
        self.cmb_panorama_codlog_field.clear()
        self.cmb_panorama_url_field.clear()
        if not layer: return
        fields = [field.name() for field in layer.fields()]
        self.cmb_panorama_codlog_field.addItems(fields)
        self.cmb_panorama_url_field.addItems(fields)

    def popular_valores_bairro(self):
        layer = self.cmb_bairro_layer.currentLayer()
        field_name = self.cmb_bairro_field.currentText()
        self.cmb_bairro_select.clear()
        if not layer or not field_name: return

        unique_values = layer.uniqueValues(layer.fields().indexFromName(field_name))
        self.cmb_bairro_select.addItems(sorted(list(unique_values)))

    def popular_valores_logradouro(self):
        bairro_layer = self.cmb_bairro_layer.currentLayer()
        bairro_field = self.cmb_bairro_field.currentText()
        bairro_selecionado = self.cmb_bairro_select.currentText()
        
        logradouro_layer = self.cmb_logradouro_layer.currentLayer()
        logradouro_codlog_field = self.cmb_logradouro_field.currentText()

        self.cmb_logradouro_select.clear()
        
        if not all([bairro_layer, bairro_field, bairro_selecionado, logradouro_layer, logradouro_codlog_field]):
            return

        # Filtra a camada de bairros para obter a geometria
        bairro_layer.selectByExpression(f"\"{bairro_field}\" = '{bairro_selecionado}'")
        feature_bairro = next(bairro_layer.getSelectedFeatures(), None)
        bairro_layer.removeSelection()
        
        if not feature_bairro: return
        geom_bairro = feature_bairro.geometry()

        # Filtra os logradouros que intersectam o bairro
        request = QgsFeatureRequest().setFilterRect(geom_bairro.boundingBox())
        codlogs = set()
        for f in logradouro_layer.getFeatures(request):
            if f.geometry().intersects(geom_bairro):
                codlogs.add(str(f[logradouro_codlog_field]))
        
        self.cmb_logradouro_select.addItems(sorted(list(codlogs)))

    def filtrar_e_exibir_pontos(self):
        logradouro_selecionado = self.cmb_logradouro_select.currentText()
        panorama_layer = self.cmb_panorama_layer.currentLayer()
        panorama_codlog_field = self.cmb_panorama_codlog_field.currentText()

        if not all([logradouro_selecionado, panorama_layer, panorama_codlog_field]):
            QMessageBox.warning(self, "Atenção", "Preencha todos os campos de camada e filtro.")
            return
        
        # Define a camada atual de panoramas para o evento de seleção
        self.current_panorama_layer = panorama_layer

        # Aplica o filtro na camada de panoramas
        filter_expression = f"\"{panorama_codlog_field}\" = '{logradouro_selecionado}'"
        panorama_layer.setSubsetString(filter_expression)
        
        iface.mapCanvas().setExtent(panorama_layer.extent())
        iface.mapCanvas().refresh()

    def visualizar_panorama_selecionado(self):
        # Esta função é acionada por qualquer mudança de seleção no mapa
        if not self.current_panorama_layer:
            return

        selected_features = self.current_panorama_layer.selectedFeatures()
        if not selected_features:
            self.view.setUrl(QUrl("about:blank"))
            return

        url_field = self.cmb_panorama_url_field.currentText()
        image_folder = self.file_widget_image_folder.filePath()

        if not url_field or not image_folder:
            QMessageBox.warning(self, "Atenção", "Selecione o campo de nome do arquivo e a pasta das imagens.")
            return

        field_idx = self.current_panorama_layer.fields().indexFromName(url_field)
        
        feature = selected_features[0]
        image_filename = feature.attributes()[field_idx]
        
        full_image_path = os.path.join(image_folder, image_filename)

        if not os.path.exists(full_image_path):
            QMessageBox.critical(self, "Erro", f"A imagem não foi encontrada no caminho:\n{full_image_path}")
            return
            
        self._load_panorama_view(full_image_path)

    def exibir_pontos_panorama(self):
        """
        Carrega e exibe os pontos de panorama para o logradouro selecionado.
        """
        codlog_selecionado = self.cmb_logradouro.currentText()
        if not codlog_selecionado:
            QMessageBox.warning(self, "Atenção", "Por favor, selecione um logradouro.")
            return

        # Limpa camadas anteriores de panorama
        for layer in QgsProject.instance().mapLayers().values():
            if layer.name() == "Pontos de Panorama":
                QgsProject.instance().removeMapLayer(layer)

        # URL do WFS da camada de panoramas (substitua pela URL correta)
        # Assumindo que a camada se chama 'pontos_panorama' e o campo é 'codlog'
        uri_panoramas = f"http://geoserver.sedur.salvador.ba.gov.br/geoserver/sedur/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=sedur:pontos_panorama&cql_filter=\"codlog\"='{codlog_selecionado}'"
        
        self.current_layer = QgsVectorLayer(uri_panoramas, "Pontos de Panorama", "WFS")

        if not self.current_layer.isValid() or self.current_layer.featureCount() == 0:
            QMessageBox.information(self, "Informação", f"Nenhum ponto de panorama encontrado para o codlog: {codlog_selecionado}")
            return
        
        # Carrega o estilo do arquivo QML que você forneceu
        style_file = os.path.join(base_folder, 'point_styles.qml')
        if os.path.exists(style_file):
            self.current_layer.loadNamedStyle(style_file)

        QgsProject.instance().addMapLayer(self.current_layer)
        iface.mapCanvas().setExtent(self.current_layer.extent())
        iface.mapCanvas().refresh()

    def visualizar_panorama_selecionado(self):
        """
        Exibe o panorama quando um ponto é selecionado no mapa.
        """
        layer = self.current_layer
        if not layer or not isinstance(layer, QgsVectorLayer):
            return

        selected_features = layer.selectedFeatures()
        if not selected_features:
            self.view.setUrl(QUrl("about:blank"))
            return

        # Lógica para obter a URL da imagem e exibi-la